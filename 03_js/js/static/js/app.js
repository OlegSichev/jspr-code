console.log('Hello from JavaScript'); //обращаемся к классу console и к методу log. В параметре пишем текст, который будет
// выведен в консоль браузера при загрузки страницы. Объект console является частью API, который браузер предоставляет
// джаваскрипту.

const form = document.getElementById('form'); //объект document по аналогии с объектом console -
// объект от API браузера для javascript. Объект document ссылается на DOM текущей страницы, соответственно сразу
// можно работать с этой объектной моделью документа. Можно вызвать метод getElementById и получить айди. Айди - это
// специальная форма, которая предполагает идентификацию и то, что объект с айди будет всегда только один. Двух
// элементов с повторяющимся айди быть не может. Соответственно, с помощью этого метода, джаваскрипт ищет в html коде
// форму с названием <form id="form"> и сохраняет эту форму в поле const form (константа, аналог final из java, какая-то
// переменная, которая точно не будет изменена).
form.addEventListener('submit', (evt) => { //addEventListener - метод, добавляющий какой-то
  // обработчик на какое-то событие. Здесь будет использоваться событийно - ориентированная модель. Первый параметр -
                                           // тип событий 'submit' (отправка формы). Как только будет вызвано событие,
  // будет вызван обработчик, который лежит во втором параметре, в данном случае evt. Событие представлено
  // лямбда выражением.
  evt.preventDefault(); //метод, который на дает перезагружаться страничке при отправке формы т.к. перезагрузка
  // странички во фронтенде равна перезагрузке приложения на бэкенде, а значит сброс всех параметров, что нам не нужно.

  // {
  //   // GET с Query URL - отправка форма с помощью GET запроса
  //   const data = new URLSearchParams(); //что б отправить параметры, вызываем конструктор класса URLSearchParams
  //   Array.from(form.elements) //что бы получить массив т.к. Мы будем работать с массивом, Мы используем Array.form, в
  //   параметр кладем form.elements, что б получить доступ к элементам из константы form
  //     .filter((el) => el.name !== '') // из полученных элементов form.elements мы хотим отфильтровать только элементы
  //     с атрибутом name, второе условие ставим !=='', что фильтруем лишь те элементы у которых имя не пустое (если не
  //     пустое, то мы его берем, если пустое, то пропускаем)
  //     .forEach((el) => data.append(el.name, el.value)); //каждый элемент (пару ключ - значение) Мы добавляем в const
  //     data. Таким образом в const data у нас находятся все элементы из форм в паре ключ - значение, у которых есть
  //     атрибут name. Соответственно добавятся значения из     <input name="value">
  //     <input name="avatar" type="file" accept="image/*"> (из HTML кода), а button (кнопка) отфильтруется, потому что
  //     у него нет name.
  //
  //   const xhr = new XMLHttpRequest(); // в константу xhr мы сохраняем ссылку на новый XHR объект (новый инстанс
  //   объект)
  //   xhr.open('GET', `/api?${data}`); //конфигурируем запрос, используем метод open и в параметрах проставляем метод
  //   GET, во втором параметре прописываем относительный путь /api разделяем знаками ?$ и прописываем объект {data},
  //   который будет отправлен на то место, где запрашивается /api в HTML коде.
  //   xhr.send(); //отправляем запрос методом send
  //   form.reset(); // очистка формы (перезагружает форму в ее изначальное состояние). Т.е. перезагрузки страницы не
  //   происходит, перезагружается (очищается) именно сама форма. Т.е. можно будет ее заново заполнить, снова нажать
  //   кнопку submit и отправить еще один запрос на backend
  // }

  // {
  //   // POST
  //   const data = new URLSearchParams();
  //   Array.from(form.elements)
  //     .filter((el) => el.name !== '') // только с атрибутом name
  //     .forEach((el) => data.append(el.name, el.value));
  //
  //   const xhr = new XMLHttpRequest();
  //   xhr.open('POST', `/api`); //вместо GET, используем метод POST
  //   xhr.send(data); //объект const data засовываем в параметр метода send, в таком случае этот объект будет отправлен
  //   в теле запроса. query =null т.к. все параметры передаются в теле запроса
  //   form.reset(); //очистка формы
  // }

  // {
  //   // Multipart - тип формы, когда можно загружать файлы
  //   const data = new FormData(form); //используем объект FormData (раньше использовали URLSearchParams, теперь
  //   формдата), ему в параметр кладем нашу константную форму (form) с которой и будут собраны данные формы
  //   const xhr = new XMLHttpRequest();
  //   xhr.open('POST', `/api`); //у нас получается метод POST с Multipart FormData в теле запроса
  //   xhr.send(data); полученный объект дата подставляем в метод send, т.е. подставляем в тело запроса
  //   form.reset();
  // }

  // {
  //   const data = new Blob(["some data"]); //BLOB расшифровывается как двоичные большие объекты, которые используются
  //   для хранения двоичных данных, таких как изображение. Либо, просто - большие массивы байт.
  //   Когда отправляются массивы байт, Мы не можем определить формат отправленного файла - это просто массив байт.
  //   const xhr = new XMLHttpRequest();
  //   xhr.open('POST', `/api`); //так как это запрос, используем POST запрос
  //   xhr.send(data); //и передаем данные в теле запроса
  // }

  // {
  //   const data = JSON.stringify({key: 'value'}); //если отправляем JSON файл, используем встроенный класс в браузер
  //   JSON, указываем ключ value
  //   const xhr = new XMLHttpRequest();
  //   xhr.open('POST', `/api`); //отправляем POST запрос
  //   xhr.setRequestHeader('Content-Type', 'application/json'); //создаем заголовок Content-Type со значением
  //   application/json т.к. мы решили, что мы передаем json. Дополнительный комментарий: в Content-Type Мы ничем не
  //   ограничены и можем написать туда, что угодно, даже просто набор символов. И сервер заработает, джаваскрипт
  //   отправит этот формат бэкенду (нашему джава коду). Другой момент то, что, если там будет рандомный набор символов,
  //   бэкенд не поймет, что это за формат и что с ним делать. Но вписать Content-Type Мы можем абсолютно любой.
  //   xhr.send(data); отправляем сам json в теле запроса
  // }

  {
    // SOP Demo
    const data = JSON.stringify({key: 'value'});
    const xhr = new XMLHttpRequest();
    xhr.open('POST', `http://localhost:9999/api`); //фиксируем конкретный адрес с которого отправляем запрос.
    // Если попытаться отправить запрос с другого origin (адреса), например, подключиться к этому адресу через
    // встроенный сервер Intelijia IDEA (там адрес другой будет и с него будем подключаться к нашему локалхост 9999),
    // то при запросе будет ошибка. Запрос будет заблокирован согласен политике безопасности CORS т.к. origin не
    // совпадают. origin - это тот адрес с которого Мы загружаем страницу и тот куда мы отправляет данные. Т.е. origin
    // клиента и origin сервера. Источник и адресат.
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(data);
  }
});

